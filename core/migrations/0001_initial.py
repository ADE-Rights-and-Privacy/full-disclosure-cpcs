# Generated by Django 3.1.3 on 2021-02-11 08:25

import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import inheritable.models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('supporting', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Grouping',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('name', models.CharField(blank=True, help_text='Name of grouping', max_length=254, verbose_name='name')),
                ('code', models.CharField(blank=True, default='', help_text='Code for grouping', max_length=50, verbose_name='code')),
                ('phone_number', models.CharField(blank=True, default='', help_text='Phone number for grouping', max_length=10, validators=[django.core.validators.RegexValidator(message='Phone number should contain only numbers and should be 10 characters long, e.g. 0123456789.', regex='^\\d{10}$')], verbose_name='phone number')),
                ('email', models.EmailField(blank=True, default='', help_text='Email address for grouping', max_length=254, verbose_name='email')),
                ('address', models.CharField(blank=True, default='', help_text='Full address for grouping', max_length=254, verbose_name='address')),
                ('is_inactive', models.BooleanField(default=False, help_text='Select if the grouping is no longer active', verbose_name='Is inactive')),
                ('inception_date', models.DateField(blank=True, help_text='Date grouping came into existence', null=True, verbose_name='inception date')),
                ('cease_date', models.DateField(blank=True, help_text='Date grouping ceased to exist', null=True, verbose_name='cease date')),
            ],
            options={
                'verbose_name': 'grouping',
                'db_table': 'fdp_grouping',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='GroupingAlias',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('name', models.CharField(help_text='Alternative name, such as a nickname, acronym, or common misspelling', max_length=254, verbose_name='alias')),
            ],
            options={
                'verbose_name': 'Grouping alias',
                'verbose_name_plural': 'Grouping aliases',
                'db_table': 'fdp_grouping_alias',
                'ordering': ['grouping', 'name'],
            },
        ),
        migrations.CreateModel(
            name='GroupingIncident',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
            ],
            options={
                'verbose_name': 'Link between grouping and incident',
                'verbose_name_plural': 'Links between groupings and incidents',
                'db_table': 'fdp_grouping_incident',
                'ordering': ['grouping', 'incident'],
            },
        ),
        migrations.CreateModel(
            name='GroupingRelationship',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
                ('as_of', models.BooleanField(default=False, help_text='Select if start date is the earliest known start date, but not necessarily the true start date', verbose_name='as of')),
            ],
            options={
                'verbose_name': 'Grouping relationship',
                'db_table': 'fdp_grouping_relationship',
                'ordering': ['subject_grouping', 'type', 'object_grouping'],
            },
        ),
        migrations.CreateModel(
            name='Incident',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('for_admin_only', models.BooleanField(default=False, help_text='Select if only administrators for the specified organizations can access.', verbose_name='admin only')),
                ('for_host_only', models.BooleanField(default=False, help_text="Select if only users belonging to the host organization can access. When combined with 'admin only', then only host administrators can access.", verbose_name='host only')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
            ],
            options={
                'verbose_name': 'Incident',
                'db_table': 'fdp_incident',
                'ordering': ['start_year', 'start_month', 'start_day', 'end_year', 'end_month', 'end_day', 'location'],
            },
        ),
        migrations.CreateModel(
            name='Person',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('for_admin_only', models.BooleanField(default=False, help_text='Select if only administrators for the specified organizations can access.', verbose_name='admin only')),
                ('for_host_only', models.BooleanField(default=False, help_text="Select if only users belonging to the host organization can access. When combined with 'admin only', then only host administrators can access.", verbose_name='host only')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('name', models.CharField(blank=True, help_text='Full name of person', max_length=254, verbose_name='name')),
                ('birth_date_range_start', models.DateField(blank=True, help_text='If birth date is known, ensure start and end ranges are the same', null=True, verbose_name='Starting range for birth date')),
                ('birth_date_range_end', models.DateField(blank=True, help_text='If birth date is known, ensure start and end ranges are the same', null=True, verbose_name='Ending range for birth date')),
                ('is_law_enforcement', models.BooleanField(default=False, help_text='Select if person is part of law enforcement', verbose_name='Is law enforcement')),
            ],
            options={
                'verbose_name': 'person',
                'verbose_name_plural': 'people',
                'db_table': 'fdp_person',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='PersonTitle',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
                ('as_of', models.BooleanField(default=False, help_text='Select if start date is the earliest known start date, but not necessarily the true start date', verbose_name='as of')),
                ('person', models.ForeignKey(help_text='Person holding title during period', on_delete=django.db.models.deletion.CASCADE, related_name='person_titles', related_query_name='person_title', to='core.person', verbose_name='person')),
                ('title', models.ForeignKey(help_text='Title of person during period', on_delete=django.db.models.deletion.CASCADE, related_name='person_titles', related_query_name='person_title', to='supporting.title', verbose_name='title')),
            ],
            options={
                'verbose_name': 'Person title',
                'db_table': 'fdp_person_title',
                'ordering': ['person', 'start_year', 'start_month', 'start_day', 'end_year', 'end_month', 'end_day'],
            },
        ),
        migrations.CreateModel(
            name='PersonRelationship',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
                ('as_of', models.BooleanField(default=False, help_text='Select if start date is the earliest known start date, but not necessarily the true start date', verbose_name='as of')),
                ('object_person', models.ForeignKey(help_text='Object person in the relationship defined by subject verb object', on_delete=django.db.models.deletion.CASCADE, related_name='object_person_relationships', related_query_name='object_person_relationship', to='core.person', verbose_name='object person')),
                ('subject_person', models.ForeignKey(help_text='Subject person in the relationship defined by "subject verb object"', on_delete=django.db.models.deletion.CASCADE, related_name='subject_person_relationships', related_query_name='subject_person_relationship', to='core.person', verbose_name='subject person')),
                ('type', models.ForeignKey(help_text='Defines the relationship, i.e. the verb portion of "subject verb object"', on_delete=django.db.models.deletion.CASCADE, related_name='person_relationships', related_query_name='person_relationship', to='supporting.personrelationshiptype', verbose_name='relationship')),
            ],
            options={
                'verbose_name': 'Person relationship',
                'db_table': 'fdp_person_relationship',
                'ordering': ['subject_person', 'type', 'object_person'],
            },
        ),
        migrations.CreateModel(
            name='PersonPhoto',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('photo', models.FileField(help_text='Photo representing person. Should be less than 2MB.', unique=True, upload_to='person/photo/%Y/%m/%d/%H/%M/%S/', validators=[inheritable.models.AbstractFileValidator.validate_photo_file_size, inheritable.models.AbstractFileValidator.validate_photo_file_extension])),
                ('person', models.ForeignKey(help_text='Person represented in photo', on_delete=django.db.models.deletion.CASCADE, related_name='person_photos', related_query_name='person_photo', to='core.person', verbose_name='person')),
            ],
            options={
                'verbose_name': 'Person photo',
                'db_table': 'fdp_person_photo',
                'ordering': ['person'],
            },
        ),
        migrations.CreateModel(
            name='PersonPayment',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
                ('as_of', models.BooleanField(default=False, help_text='Select if start date is the earliest known start date, but not necessarily the true start date', verbose_name='as of')),
                ('base_salary', models.DecimalField(blank=True, decimal_places=2, help_text='Base salary for person during period', max_digits=8, null=True, verbose_name='base salary')),
                ('regular_hours', models.DecimalField(blank=True, decimal_places=2, help_text='Hours worked, excluding overtime, by person during period', max_digits=6, null=True, verbose_name='regular hours')),
                ('regular_gross_pay', models.DecimalField(blank=True, decimal_places=2, help_text='Gross pay, excluding overtime, for person during period', max_digits=8, null=True, verbose_name='regular gross pay')),
                ('overtime_hours', models.DecimalField(blank=True, decimal_places=2, help_text='Overtime hours worked by person during period', max_digits=6, null=True, verbose_name='overtime hours')),
                ('overtime_pay', models.DecimalField(blank=True, decimal_places=2, help_text='Overtime pay for person during period', max_digits=8, null=True, verbose_name='overtime pay')),
                ('total_other_pay', models.DecimalField(blank=True, decimal_places=2, help_text='Total other pay for person during period', max_digits=8, null=True, verbose_name='total other pay')),
                ('county', models.ForeignKey(blank=True, help_text='County where work was performed', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='person_payments', related_query_name='person_payment', to='supporting.county', verbose_name='county')),
                ('leave_status', models.ForeignKey(blank=True, help_text='Leave status during pay period', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='person_payments', related_query_name='person_payment', to='supporting.leavestatus', verbose_name='leave status')),
                ('person', models.ForeignKey(help_text='Person that was paid', on_delete=django.db.models.deletion.CASCADE, related_name='person_payments', related_query_name='person_payment', to='core.person', verbose_name='person')),
            ],
            options={
                'verbose_name': 'person payment',
                'db_table': 'fdp_person_payment',
                'ordering': ['person', 'start_year', 'start_month', 'start_day', 'end_year', 'end_month', 'end_day'],
            },
        ),
        migrations.CreateModel(
            name='PersonIncident',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('is_guess', models.BooleanField(default=False, help_text='Select if link is a guess', verbose_name='Is this a guess')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('known_info', models.JSONField(blank=True, help_text='Known information to create record.', null=True, verbose_name='known information')),
                ('incident', models.ForeignKey(help_text='Incident which is linked to the person', on_delete=django.db.models.deletion.CASCADE, related_name='person_incidents', related_query_name='person_incident', to='core.incident', verbose_name='incident')),
                ('person', models.ForeignKey(help_text='Person who is linked to the incident', on_delete=django.db.models.deletion.CASCADE, related_name='person_incidents', related_query_name='person_incident', to='core.person', verbose_name='person')),
                ('situation_role', models.ForeignKey(blank=True, help_text="Categorizes the person's involvement in the incident", null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='person_incidents', related_query_name='person_incident', to='supporting.situationrole', verbose_name='situation role')),
                ('tags', models.ManyToManyField(blank=True, db_table='fdp_person_incident_person_incident_tag', help_text='Tags describing link between person and incident', related_name='person_incidents', related_query_name='person_incident', to='supporting.PersonIncidentTag', verbose_name='tags')),
            ],
            options={
                'verbose_name': 'Link between person and incident',
                'verbose_name_plural': 'Links between people and incidents',
                'db_table': 'fdp_person_incident',
                'ordering': ['person', 'incident'],
            },
        ),
        migrations.CreateModel(
            name='PersonIdentifier',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
                ('as_of', models.BooleanField(default=False, help_text='Select if start date is the earliest known start date, but not necessarily the true start date', verbose_name='as of')),
                ('identifier', models.CharField(help_text="Identifier number, such as the driver's license number, passport number, or similar", max_length=254, verbose_name='identifier')),
                ('person', models.ForeignKey(help_text='Person linked to this identifier', on_delete=django.db.models.deletion.CASCADE, related_name='person_identifiers', related_query_name='person_identifier', to='core.person', verbose_name='person')),
                ('person_identifier_type', models.ForeignKey(help_text="Type of documentation containing identifier, such as driver's license, passport, or similar", on_delete=django.db.models.deletion.CASCADE, related_name='person_identifiers', related_query_name='person_identifier', to='supporting.personidentifiertype', verbose_name='type')),
            ],
            options={
                'verbose_name': 'Person identifier',
                'db_table': 'fdp_person_identifier',
                'ordering': ['person', 'person_identifier_type', 'start_year', 'start_month', 'start_day', 'end_year', 'end_month', 'end_day'],
            },
        ),
        migrations.CreateModel(
            name='PersonGrouping',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('start_year', models.PositiveSmallIntegerField(default=0, help_text='Year of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='starting year')),
                ('start_month', models.PositiveSmallIntegerField(default=0, help_text='Month of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='starting month')),
                ('start_day', models.PositiveSmallIntegerField(default=0, help_text='Day of start, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='starting day')),
                ('end_year', models.PositiveSmallIntegerField(default=0, help_text='Year of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_year], verbose_name='ending year')),
                ('end_month', models.PositiveSmallIntegerField(default=0, help_text='Month of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_month], verbose_name='ending month')),
                ('end_day', models.PositiveSmallIntegerField(default=0, help_text='Day of end, use 0 if unknown', validators=[inheritable.models.AbstractDateValidator.validate_day], verbose_name='ending day')),
                ('as_of', models.BooleanField(default=False, help_text='Select if start date is the earliest known start date, but not necessarily the true start date', verbose_name='as of')),
                ('is_inactive', models.BooleanField(default=False, help_text='Select if the link between person and grouping is no longer active', verbose_name='Is inactive')),
                ('grouping', models.ForeignKey(help_text='Grouping which is linked to the person', on_delete=django.db.models.deletion.CASCADE, related_name='person_groupings', related_query_name='person_grouping', to='core.grouping', verbose_name='grouping')),
                ('person', models.ForeignKey(help_text='Person who is linked to the grouping', on_delete=django.db.models.deletion.CASCADE, related_name='person_groupings', related_query_name='person_grouping', to='core.person', verbose_name='person')),
                ('type', models.ForeignKey(blank=True, help_text='Category for link between the person and grouping', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='person_groupings', related_query_name='person_grouping', to='supporting.persongroupingtype', verbose_name='type')),
            ],
            options={
                'verbose_name': 'Link between person and grouping',
                'verbose_name_plural': 'Links between people and groupings',
                'db_table': 'fdp_person_grouping',
                'ordering': ['start_year', 'start_month', 'start_day', 'end_year', 'end_month', 'end_day', 'grouping', 'person'],
            },
        ),
        migrations.CreateModel(
            name='PersonContact',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('phone_number', models.CharField(blank=True, help_text='Phone number for person', max_length=10, validators=[django.core.validators.RegexValidator(message='Phone number should contain only numbers and should be 10 characters long, e.g. 0123456789.', regex='^\\d{10}$')], verbose_name='phone number')),
                ('email', models.EmailField(blank=True, help_text='Email address for', max_length=254, verbose_name='email')),
                ('address', models.CharField(blank=True, default='', help_text='Building number, street name, unit # and PO box if available', max_length=254, verbose_name='address')),
                ('city', models.CharField(blank=True, default='', help_text='City for address of person', max_length=254, verbose_name='city')),
                ('zip_code', models.CharField(blank=True, default='', help_text='ZIP code for address of person', max_length=254, verbose_name='zip code')),
                ('is_current', models.BooleanField(default=False, help_text='Select if contact information is currently used by person', verbose_name='Is current')),
                ('person', models.ForeignKey(help_text='Person linked to contact information', on_delete=django.db.models.deletion.CASCADE, related_name='person_contacts', related_query_name='person_contact', to='core.person', verbose_name='person')),
                ('state', models.ForeignKey(blank=True, help_text='State for address of person', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='person_contacts', related_query_name='person_contact', to='supporting.state', verbose_name='state')),
            ],
            options={
                'verbose_name': 'person contact',
                'db_table': 'fdp_person_contact',
                'ordering': ['person', 'is_current', 'state', 'city', 'address'],
            },
        ),
        migrations.CreateModel(
            name='PersonAlias',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_archived', models.BooleanField(default=False, help_text='Select if record is archived', verbose_name='Is archived')),
                ('description', models.TextField(blank=True, help_text='Verbose, user-friendly narrative', verbose_name='Description')),
                ('name', models.CharField(help_text='Alternative name, such as a nickname, acronym, or common misspelling', max_length=254, verbose_name='alias')),
                ('person', models.ForeignKey(help_text='Person who is known by this alias', on_delete=django.db.models.deletion.CASCADE, related_name='person_aliases', related_query_name='person_alias', to='core.person', verbose_name='person')),
            ],
            options={
                'verbose_name': 'Person alias',
                'verbose_name_plural': 'Person aliases',
                'db_table': 'fdp_person_alias',
                'ordering': ['person', 'name'],
            },
        ),
    ]
